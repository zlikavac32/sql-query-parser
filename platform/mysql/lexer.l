%option outfile="scanner.c" noyywrap warn nodefault caseless prefix="mysql"

%{

#include "lexer.h"
#include "stdio.h"

size_t consumed_chars = 0;

#undef YY_NULL
#define YY_USER_ACTION consumed_chars += mysqlleng;
#define YY_NO_UNPUT 1
#define YY_NULL token_new(T_EOF, NULL, 0, consumed_chars)
#define YY_DECL struct token lexer_lex()

int mysqllex_destroy (void);
void mysqlset_in(FILE *in);
FILE *mysqlget_in();

void mysql_lexer_use_buffer(const char *buff, size_t len) {
    FILE *f = fmemopen((void *) buff, len, "r");
    consumed_chars = 0;
    mysqlset_in(f);
}

void mysql_lexer_clear_buffer() {
    fclose(yyget_in());
    mysqllex_destroy();
}

#define RETURN_TOKEN_FOR(type) return token_new(type, mysqltext, mysqlleng, consumed_chars - mysqlleng)

%} 


%%
ALL      RETURN_TOKEN_FOR(T_K_ALL);
DISTINCT      RETURN_TOKEN_FOR(T_K_DISTINCT);
DISTINCTROW      RETURN_TOKEN_FOR(T_K_DISTINCTROW);
HIGH_PRIORITY      RETURN_TOKEN_FOR(T_K_HIGH_PRIORITY);
STRAIGHT_JOIN      RETURN_TOKEN_FOR(T_K_STRAIGHT_JOIN);
SQL_SMALL_RESULT      RETURN_TOKEN_FOR(T_K_SQL_SMALL_RESULT);
SQL_BIG_RESULT      RETURN_TOKEN_FOR(T_K_SQL_BIG_RESULT);
SQL_BUFFER_RESULT      RETURN_TOKEN_FOR(T_K_SQL_BUFFER_RESULT);
SQL_CACHE      RETURN_TOKEN_FOR(T_K_SQL_CACHE);
SQL_NO_CACHE      RETURN_TOKEN_FOR(T_K_SQL_NO_CACHE);
SQL_CALC_FOUND_ROWS      RETURN_TOKEN_FOR(T_K_SQL_CALC_FOUND_ROWS);
BINARY      RETURN_TOKEN_FOR(T_K_BINARY);
EXISTS      RETURN_TOKEN_FOR(T_K_EXISTS);
SELECT      RETURN_TOKEN_FOR(T_K_SELECT);
NULL      RETURN_TOKEN_FOR(T_K_NULL);
TRUE      RETURN_TOKEN_FOR(T_K_TRUE);
FALSE      RETURN_TOKEN_FOR(T_K_FALSE);
COLLATE      RETURN_TOKEN_FOR(T_K_COLLATE);
DATE      RETURN_TOKEN_FOR(T_K_DATE);
TIME      RETURN_TOKEN_FOR(T_K_TIME);
TIMESTAMP      RETURN_TOKEN_FOR(T_K_TIMESTAMP);
INTERVAL      RETURN_TOKEN_FOR(T_K_INTERVAL);
CASE      RETURN_TOKEN_FOR(T_K_CASE);
WHEN      RETURN_TOKEN_FOR(T_K_WHEN);
THEN      RETURN_TOKEN_FOR(T_K_THEN);
ELSE      RETURN_TOKEN_FOR(T_K_ELSE);
END      RETURN_TOKEN_FOR(T_K_END);
MATCH      RETURN_TOKEN_FOR(T_K_MATCH);
AGAINST      RETURN_TOKEN_FOR(T_K_AGAINST);
IN      RETURN_TOKEN_FOR(T_K_IN);
NATURAL      RETURN_TOKEN_FOR(T_K_NATURAL);
LANGUAGE      RETURN_TOKEN_FOR(T_K_LANGUAGE);
MODE      RETURN_TOKEN_FOR(T_K_MODE);
WITH      RETURN_TOKEN_FOR(T_K_WITH);
QUERY      RETURN_TOKEN_FOR(T_K_QUERY);
EXPANSION      RETURN_TOKEN_FOR(T_K_EXPANSION);
BOOLEAN      RETURN_TOKEN_FOR(T_K_BOOLEAN);
ROW      RETURN_TOKEN_FOR(T_K_ROW);
MOD      RETURN_TOKEN_FOR(T_K_MOD);
DIV      RETURN_TOKEN_FOR(T_K_DIV);
SOUNDS      RETURN_TOKEN_FOR(T_K_SOUNDS);
LIKE      RETURN_TOKEN_FOR(T_K_LIKE);
NOT      RETURN_TOKEN_FOR(T_K_NOT);
BETWEEN      RETURN_TOKEN_FOR(T_K_BETWEEN);
REGEXP      RETURN_TOKEN_FOR(T_K_REGEXP);
AND      RETURN_TOKEN_FOR(T_K_AND);
ESCAPE      RETURN_TOKEN_FOR(T_K_ESCAPE);
IS      RETURN_TOKEN_FOR(T_K_IS);
UNKNOWN      RETURN_TOKEN_FOR(T_K_UNKNOWN);
XOR      RETURN_TOKEN_FOR(T_K_XOR);
OR      RETURN_TOKEN_FOR(T_K_OR);
ANY      RETURN_TOKEN_FOR(T_K_ANY);
AS      RETURN_TOKEN_FOR(T_K_AS);
INTO      RETURN_TOKEN_FOR(T_K_INTO);
DUMPFILE      RETURN_TOKEN_FOR(T_K_DUMPFILE);
OUTFILE      RETURN_TOKEN_FOR(T_K_OUTFILE);
CHARACTER      RETURN_TOKEN_FOR(T_K_CHARACTER);
SET      RETURN_TOKEN_FOR(T_K_SET);
COLUMNS      RETURN_TOKEN_FOR(T_K_COLUMNS);
FIELDS      RETURN_TOKEN_FOR(T_K_FIELDS);
TERMINATED      RETURN_TOKEN_FOR(T_K_TERMINATED);
BY      RETURN_TOKEN_FOR(T_K_BY);
OPTIONALLY      RETURN_TOKEN_FOR(T_K_OPTIONALLY);
ENCLOSED      RETURN_TOKEN_FOR(T_K_ENCLOSED);
ESCAPED      RETURN_TOKEN_FOR(T_K_ESCAPED);
LINES      RETURN_TOKEN_FOR(T_K_LINES);
STARTING      RETURN_TOKEN_FOR(T_K_STARTING);
FROM      RETURN_TOKEN_FOR(T_K_FROM);
PARTITION      RETURN_TOKEN_FOR(T_K_PARTITION);
USE      RETURN_TOKEN_FOR(T_K_USE);
INDEX      RETURN_TOKEN_FOR(T_K_INDEX);
KEY      RETURN_TOKEN_FOR(T_K_KEY);
FOR      RETURN_TOKEN_FOR(T_K_FOR);
JOIN      RETURN_TOKEN_FOR(T_K_JOIN);
ORDER      RETURN_TOKEN_FOR(T_K_ORDER);
GROUP      RETURN_TOKEN_FOR(T_K_GROUP);
IGNORE      RETURN_TOKEN_FOR(T_K_IGNORE);
FORCE      RETURN_TOKEN_FOR(T_K_FORCE);
INNER      RETURN_TOKEN_FOR(T_K_INNER);
LEFT      RETURN_TOKEN_FOR(T_K_LEFT);
RIGHT      RETURN_TOKEN_FOR(T_K_RIGHT);
OUTER      RETURN_TOKEN_FOR(T_K_OUTER);
ON      RETURN_TOKEN_FOR(T_K_ON);
USING      RETURN_TOKEN_FOR(T_K_USING);
STRAIGHT      RETURN_TOKEN_FOR(T_K_STRAIGHT);
CROSS      RETURN_TOKEN_FOR(T_K_CROSS);
WHERE      RETURN_TOKEN_FOR(T_K_WHERE);
HAVING      RETURN_TOKEN_FOR(T_K_HAVING);
ASC      RETURN_TOKEN_FOR(T_K_ASC);
DESC      RETURN_TOKEN_FOR(T_K_DESC);
LIMIT      RETURN_TOKEN_FOR(T_K_LIMIT);
OFFSET      RETURN_TOKEN_FOR(T_K_OFFSET);
PROCEDURE      RETURN_TOKEN_FOR(T_K_PROCEDURE);
UPDATE      RETURN_TOKEN_FOR(T_K_UPDATE);
LOCK      RETURN_TOKEN_FOR(T_K_LOCK);
SHARE      RETURN_TOKEN_FOR(T_K_SHARE);

[<>]=?|<>|!?= RETURN_TOKEN_FOR(T_COMPARISON_OPERATOR);
"<=>"      RETURN_TOKEN_FOR(T_ARROW);
"&&"      RETURN_TOKEN_FOR(T_AND);
"|"      RETURN_TOKEN_FOR(T_BIT_OR);
"&"      RETURN_TOKEN_FOR(T_BIT_AND);
"<<"      RETURN_TOKEN_FOR(T_LEFT_SHIFT);
">>"      RETURN_TOKEN_FOR(T_RIGHT_SHIFT);
"/"      RETURN_TOKEN_FOR(T_DIV);
"%"      RETURN_TOKEN_FOR(T_MOD);
"^"      RETURN_TOKEN_FOR(T_BIT_XOR);
"||"      RETURN_TOKEN_FOR(T_OR);
"+"      RETURN_TOKEN_FOR(T_PLUS);
"-"      RETURN_TOKEN_FOR(T_MINUS);
"*"      RETURN_TOKEN_FOR(T_MULT);
"!"      RETURN_TOKEN_FOR(T_NOT);
"~"      RETURN_TOKEN_FOR(T_BIT_NOT);
,      RETURN_TOKEN_FOR(T_COMMA);
"("      RETURN_TOKEN_FOR(T_OPEN_PAREN);
")"      RETURN_TOKEN_FOR(T_CLOSE_PAREN);
"?"      RETURN_TOKEN_FOR(T_PLACEHOLDER);

b'[01]+'     RETURN_TOKEN_FOR(T_BIT_VALUE);
0x[a-fA-F0-9]+|x'[a-fA-F0-9]+'     RETURN_TOKEN_FOR(T_HEX_VALUE);
YEAR_MONTH|YEAR|WEEK|SECOND_MICROSECOND|SECOND|QUARTER|MONTH|MINUTE_SECOND|MINUTE_MICROSECOND|MINUTE|MICROSECOND|HOUR_SECOND|HOUR_MINUTE|HOUR_MICROSECOND|HOUR|DAY_SECOND|DAY_MINUTE|DAY_MICROSECOND|DAY_HOUR|DAY      RETURN_TOKEN_FOR(T_INTERVAL_UNIT);
([[:digit:]]+("."[[:digit:]]*)?|"."[[:digit:]]+)([eE][+-]?[[:digit:]]+)?     RETURN_TOKEN_FOR(T_NUMBER);
[[:space:]]+    RETURN_TOKEN_FOR(T_WHITE_SPACE);
[[:alnum:]]*'(\\.|[^'\\]+)*'([[:space:]]*[[:alnum:]]*'(\\.|[^'\\]+)*')*|[[:alnum:]]*\"(\\.|[^\"\\]+)*\"([[:space:]]*[[:alnum:]]*\"(\\.|[^\"\\]+)*\")*    RETURN_TOKEN_FOR(T_STRING);
[a-z_$][a-z_$0-9]*|`[^`]+`    RETURN_TOKEN_FOR(T_IDENTIFIER);
@@?([a-z_$][a-z_$0-9]*|`[^`]+`)    RETURN_TOKEN_FOR(T_VARIABLE);
([a-z_$][a-z_$0-9]*|`[^`]+`)("."([a-z_$][a-z_$0-9]*|`[^`]+`)){1,2}    RETURN_TOKEN_FOR(T_QUALIFIED_IDENTIFIER);
([a-z_$][a-z_$0-9]*|`[^`]+`)"."("*"|([a-z_$][a-z_$0-9]*|`[^`]+`)".*")    RETURN_TOKEN_FOR(T_WILDCARD_IDENTIFIER);
. RETURN_TOKEN_FOR(T_UNKNOWN);
%% 
